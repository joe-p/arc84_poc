#pragma version 10
intcblock 32 1 256 0 8
bytecblock 0x151f7c75 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF 0x00 0x746f74616c537570706c79 0x646563696d616c73 0x73796d626f6c 0x6e616d65 0x

// This TEAL was generated by TEALScript v0.106.3
// https://github.com/algorandfoundation/TEALScript

// This contract is compliant with and/or implements the following ARCs: [ ARC4 ]

// The following ten lines of TEAL handle initial program flow
// This pattern is used to make it easy for anyone to parse the start of the program and determine if a specific action is allowed
// Here, action refers to the OnComplete in combination with whether the app is being created or called
// Every possible action for this contract is represented in the switch statement
// If the action is not implemented in the contract, its respective branch will be "*NOT_IMPLEMENTED" which just contains "err"
txn ApplicationID
!
pushint 6
*
txn OnCompletion
+
switch *call_NoOp *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *create_NoOp *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED

*NOT_IMPLEMENTED:
	// The requested action is not implemented in this contract. Are you using the correct OnComplete? Did you set your app ID?
	err

// createApplication(byte[32],byte[8],uint8,uint256)void
*abi_route_createApplication:
	// total: uint256
	txna ApplicationArgs 4
	dup
	len
	intc 0 // 32
	==

	// argument 0 (total) for createApplication must be a uint256
	assert

	// decimals: uint8
	txna ApplicationArgs 3
	dup
	len
	intc 1 // 1
	==

	// argument 1 (decimals) for createApplication must be a uint8
	assert
	btoi

	// symbol: byte[8]
	txna ApplicationArgs 2
	dup
	len
	intc 4 // 8
	==

	// argument 2 (symbol) for createApplication must be a byte[8]
	assert

	// name: byte[32]
	txna ApplicationArgs 1
	dup
	len
	intc 0 // 32
	==

	// argument 3 (name) for createApplication must be a byte[32]
	assert

	// execute createApplication(byte[32],byte[8],uint8,uint256)void
	callsub createApplication
	intc 1 // 1
	return

// createApplication(name: bytes<32>, symbol: bytes<8>, decimals: uint8, total: uint256): void
createApplication:
	proto 4 0

	// contracts/ARC200.algo.ts:34
	// this.name.value = name
	bytec 6 //  "name"
	frame_dig -1 // name: bytes<32>
	app_global_put

	// contracts/ARC200.algo.ts:35
	// this.symbol.value = symbol
	bytec 5 //  "symbol"
	frame_dig -2 // symbol: bytes<8>
	app_global_put

	// contracts/ARC200.algo.ts:36
	// this.decimals.value = decimals
	bytec 4 //  "decimals"
	frame_dig -3 // decimals: uint8
	itob
	extract 7 1
	app_global_put

	// contracts/ARC200.algo.ts:37
	// this.totalSupply.value = total
	bytec 3 //  "totalSupply"
	frame_dig -4 // total: uint256
	app_global_put

	// contracts/ARC200.algo.ts:38
	// this.balances(this.txn.sender).value = total
	txn Sender
	frame_dig -4 // total: uint256
	box_put
	retsub

// arc200_name()byte[32]
*abi_route_arc200_name:
	// The ABI return prefix
	bytec 0 // 0x151f7c75

	// execute arc200_name()byte[32]
	callsub arc200_name
	concat
	log
	intc 1 // 1
	return

// arc200_name(): bytes<32>
arc200_name:
	proto 0 1

	// contracts/ARC200.algo.ts:42
	// return this.name.value;
	bytec 6 //  "name"
	app_global_get
	retsub

// arc200_symbol()byte[8]
*abi_route_arc200_symbol:
	// The ABI return prefix
	bytec 0 // 0x151f7c75

	// execute arc200_symbol()byte[8]
	callsub arc200_symbol
	concat
	log
	intc 1 // 1
	return

// arc200_symbol(): bytes<8>
arc200_symbol:
	proto 0 1

	// contracts/ARC200.algo.ts:46
	// return this.symbol.value;
	bytec 5 //  "symbol"
	app_global_get
	retsub

// arc200_decimals()uint8
*abi_route_arc200_decimals:
	// The ABI return prefix
	bytec 0 // 0x151f7c75

	// execute arc200_decimals()uint8
	callsub arc200_decimals
	itob
	dup
	bitlen
	intc 4 // 8
	<=

	// arc200_decimals return value overflowed 8 bits
	assert
	extract 7 1
	concat
	log
	intc 1 // 1
	return

// arc200_decimals(): uint8
arc200_decimals:
	proto 0 1

	// contracts/ARC200.algo.ts:50
	// return this.decimals.value;
	bytec 4 //  "decimals"
	app_global_get
	btoi
	retsub

// arc200_totalSupply()uint256
*abi_route_arc200_totalSupply:
	// The ABI return prefix
	bytec 0 // 0x151f7c75

	// execute arc200_totalSupply()uint256
	callsub arc200_totalSupply
	dup
	bitlen
	intc 2 // 256
	<=

	// arc200_totalSupply return value overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	concat
	log
	intc 1 // 1
	return

// arc200_totalSupply(): uint256
arc200_totalSupply:
	proto 0 1

	// contracts/ARC200.algo.ts:54
	// return this.totalSupply.value;
	bytec 3 //  "totalSupply"
	app_global_get
	retsub

// arc200_balanceOf(address)uint256
*abi_route_arc200_balanceOf:
	// The ABI return prefix
	bytec 0 // 0x151f7c75

	// account: address
	txna ApplicationArgs 1
	dup
	len
	intc 0 // 32
	==

	// argument 0 (account) for arc200_balanceOf must be a address
	assert

	// execute arc200_balanceOf(address)uint256
	callsub arc200_balanceOf
	dup
	bitlen
	intc 2 // 256
	<=

	// arc200_balanceOf return value overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	concat
	log
	intc 1 // 1
	return

// arc200_balanceOf(account: Address): uint256
arc200_balanceOf:
	proto 1 1

	// contracts/ARC200.algo.ts:58
	// return this.balances(account).value;
	frame_dig -1 // account: Address
	box_get

	// box value does not exist: this.balances(account).value
	assert
	retsub

// transfer(from: Address, to: Address, amount: uint256): boolean
transfer:
	proto 3 1

	// contracts/ARC200.algo.ts:62
	// this.balances(from).value -= amount
	frame_dig -1 // from: Address
	box_get

	// box value does not exist: this.balances(from).value
	assert
	frame_dig -3 // amount: uint256
	b-
	frame_dig -1 // from: Address
	swap
	box_put

	// contracts/ARC200.algo.ts:63
	// this.balances(to).value += amount
	frame_dig -2 // to: Address
	box_get

	// box value does not exist: this.balances(to).value
	assert
	frame_dig -3 // amount: uint256
	b+
	frame_dig -2 // to: Address
	swap
	box_put

	// contracts/ARC200.algo.ts:64
	// this.arc200_Transfer.log({ from: from, to: to, value: amount })
	pushbytes 0x7983c35c // arc200_Transfer(address,address,uint256)
	frame_dig -1 // from: Address
	frame_dig -2 // to: Address
	concat
	frame_dig -3 // amount: uint256
	concat
	concat
	log

	// contracts/ARC200.algo.ts:66
	// return true;
	intc 1 // 1
	retsub

// arc200_transferFrom(address,address,uint256)bool
*abi_route_arc200_transferFrom:
	// The ABI return prefix
	bytec 0 // 0x151f7c75

	// amount: uint256
	txna ApplicationArgs 3
	dup
	len
	intc 0 // 32
	==

	// argument 0 (amount) for arc200_transferFrom must be a uint256
	assert

	// to: address
	txna ApplicationArgs 2
	dup
	len
	intc 0 // 32
	==

	// argument 1 (to) for arc200_transferFrom must be a address
	assert

	// from: address
	txna ApplicationArgs 1
	dup
	len
	intc 0 // 32
	==

	// argument 2 (from) for arc200_transferFrom must be a address
	assert

	// execute arc200_transferFrom(address,address,uint256)bool
	callsub arc200_transferFrom
	bytec 2 // 0x00
	intc 3 // 0
	uncover 2
	setbit
	concat
	log
	intc 1 // 1
	return

// arc200_transferFrom(from: Address, to: Address, amount: uint256): boolean
arc200_transferFrom:
	proto 3 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 7 // 0x

	// contracts/ARC200.algo.ts:70
	// approval: Approval = { owner: from, spender: this.txn.sender }
	frame_dig -1 // from: Address
	txn Sender
	concat
	frame_bury 0 // approval: Approval

	// contracts/ARC200.algo.ts:72
	// assert(this.allowances(approval).value >= amount)
	frame_dig 0 // approval: Approval
	box_get

	// box value does not exist: this.allowances(approval).value
	assert
	frame_dig -3 // amount: uint256
	b>=
	assert

	// contracts/ARC200.algo.ts:73
	// this.allowances(approval).value -= amount
	frame_dig 0 // approval: Approval
	box_get

	// box value does not exist: this.allowances(approval).value
	assert
	frame_dig -3 // amount: uint256
	b-
	frame_dig 0 // approval: Approval
	swap
	box_put

	// contracts/ARC200.algo.ts:75
	// return this.transfer(from, to, amount);
	frame_dig -3 // amount: uint256
	frame_dig -2 // to: Address
	frame_dig -1 // from: Address
	callsub transfer

	// set the subroutine return value
	frame_bury 0
	retsub

// arc200_transfer(address,uint256)bool
*abi_route_arc200_transfer:
	// The ABI return prefix
	bytec 0 // 0x151f7c75

	// amount: uint256
	txna ApplicationArgs 2
	dup
	len
	intc 0 // 32
	==

	// argument 0 (amount) for arc200_transfer must be a uint256
	assert

	// to: address
	txna ApplicationArgs 1
	dup
	len
	intc 0 // 32
	==

	// argument 1 (to) for arc200_transfer must be a address
	assert

	// execute arc200_transfer(address,uint256)bool
	callsub arc200_transfer
	bytec 2 // 0x00
	intc 3 // 0
	uncover 2
	setbit
	concat
	log
	intc 1 // 1
	return

// arc200_transfer(to: Address, amount: uint256): boolean
arc200_transfer:
	proto 2 1

	// contracts/ARC200.algo.ts:79
	// return this.transfer(this.txn.sender, to, amount);
	frame_dig -2 // amount: uint256
	frame_dig -1 // to: Address
	txn Sender
	callsub transfer
	retsub

// arc200_approve(address,uint256)bool
*abi_route_arc200_approve:
	// The ABI return prefix
	bytec 0 // 0x151f7c75

	// value: uint256
	txna ApplicationArgs 2
	dup
	len
	intc 0 // 32
	==

	// argument 0 (value) for arc200_approve must be a uint256
	assert

	// spender: address
	txna ApplicationArgs 1
	dup
	len
	intc 0 // 32
	==

	// argument 1 (spender) for arc200_approve must be a address
	assert

	// execute arc200_approve(address,uint256)bool
	callsub arc200_approve
	bytec 2 // 0x00
	intc 3 // 0
	uncover 2
	setbit
	concat
	log
	intc 1 // 1
	return

// arc200_approve(spender: Address, value: uint256): boolean
arc200_approve:
	proto 2 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 7 // 0x

	// contracts/ARC200.algo.ts:83
	// approval: Approval = { owner: this.txn.sender, spender: spender }
	txn Sender
	frame_dig -1 // spender: Address
	concat
	frame_bury 0 // approval: Approval

	// *if0_condition
	// contracts/ARC200.algo.ts:84
	// !this.allowances(approval).exists
	frame_dig 0 // approval: Approval
	box_len
	swap
	pop
	!
	bz *if0_else

	// *if0_consequent
	// contracts/ARC200.algo.ts:85
	// this.allowances(approval).value = value
	frame_dig 0 // approval: Approval
	frame_dig -2 // value: uint256
	box_put
	b *if0_end

*if0_else:
	// contracts/ARC200.algo.ts:87
	// this.allowances(approval).value += value
	frame_dig 0 // approval: Approval
	box_get

	// box value does not exist: this.allowances(approval).value
	assert
	frame_dig -2 // value: uint256
	b+
	frame_dig 0 // approval: Approval
	swap
	box_put

*if0_end:
	// contracts/ARC200.algo.ts:90
	// return true;
	intc 1 // 1

	// set the subroutine return value
	frame_bury 0
	retsub

// arc200_allowance(address,address)uint256
*abi_route_arc200_allowance:
	// The ABI return prefix
	bytec 0 // 0x151f7c75

	// sender: address
	txna ApplicationArgs 2
	dup
	len
	intc 0 // 32
	==

	// argument 0 (sender) for arc200_allowance must be a address
	assert

	// owner: address
	txna ApplicationArgs 1
	dup
	len
	intc 0 // 32
	==

	// argument 1 (owner) for arc200_allowance must be a address
	assert

	// execute arc200_allowance(address,address)uint256
	callsub arc200_allowance
	dup
	bitlen
	intc 2 // 256
	<=

	// arc200_allowance return value overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	concat
	log
	intc 1 // 1
	return

// arc200_allowance(owner: Address, sender: Address): uint256
arc200_allowance:
	proto 2 1

	// contracts/ARC200.algo.ts:94
	// return this.allowances({ owner: owner, spender: sender }).value;
	frame_dig -1 // owner: Address
	frame_dig -2 // sender: Address
	concat
	box_get

	// box value does not exist: this.allowances({ owner: owner, spender: sender }).value
	assert
	retsub

*create_NoOp:
	pushbytes 0x8529f783 // method "createApplication(byte[32],byte[8],uint8,uint256)void"
	txna ApplicationArgs 0
	match *abi_route_createApplication

	// this contract does not implement the given ABI method for create NoOp
	err

*call_NoOp:
	pushbytes 0x657d13ec // method "arc200_name()byte[32]"
	pushbytes 0xb6ae1a25 // method "arc200_symbol()byte[8]"
	pushbytes 0x84ec13d5 // method "arc200_decimals()uint8"
	pushbytes 0xec996041 // method "arc200_totalSupply()uint256"
	pushbytes 0x82e573c4 // method "arc200_balanceOf(address)uint256"
	pushbytes 0x4a968f8f // method "arc200_transferFrom(address,address,uint256)bool"
	pushbytes 0xda7025b9 // method "arc200_transfer(address,uint256)bool"
	pushbytes 0xb5422125 // method "arc200_approve(address,uint256)bool"
	pushbytes 0xbbb319f3 // method "arc200_allowance(address,address)uint256"
	txna ApplicationArgs 0
	match *abi_route_arc200_name *abi_route_arc200_symbol *abi_route_arc200_decimals *abi_route_arc200_totalSupply *abi_route_arc200_balanceOf *abi_route_arc200_transferFrom *abi_route_arc200_transfer *abi_route_arc200_approve *abi_route_arc200_allowance

	// this contract does not implement the given ABI method for call NoOp
	err